
![[十大排序.jpg]]

这里的「稳定」是指当排序后两个相等键值的顺序和排序之前的顺序相同；  
- n: 代表数据规模及数据量大小
- k: 桶的个数
- In-place: 不占用额外内存，只占用常数内存
- Out-place: 占用额外内存

<span style="color:yellow; ">1、冒泡排序</span>  

冒泡排序是排序算法中较为简单的一种，英文称为`Bubble Sort。`它遍历所有的数据，每次对相邻元素进行两两比较，如果顺序和预先规定的顺序不一致，则进行位置交换；这样一次遍历会将最大或最小的数据上浮到顶端，之后再重复同样的操作，直到所有的数据有序。
![[冒泡排序动图.gif]]

```
public static void BubbleSort(int[] arr)
{
    int n = arr.Length;
    for (int i = 0; i < n - 1; i++)
    {
        for (int j = 0; j < n - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                // 交换arr[j]和arr[j + 1]的位置
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

<span style="color:yellow; ">2、选择排序</span>
  选择排序简单直观，英文称为`Selection Sort，`先在数据中找出最大或最小的元素，放到序列的起始；然后再从余下的数据中继续寻找最大或最小的元素，依次放到排序序列中，直到所有数据样本排序完成。
  ![[选择排序.gif]]

```
public static void SelectionSort(int[] arr)
{
    int n = arr.Length;
    for (int i = 0; i < n - 1; i++)
    {
        int minIndex = i;
        for (int j = i + 1; j < n; j++)
        {
            if (arr[j] < arr[minIndex])
            {
                minIndex = j;
            }
        }
        // 交换arr[i]和arr[minIndex]的位置
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```

<span style="color:yellow; ">3、插入排序</span>
插入排序英文称为`Insertion Sort，`它通过构建有序序列，对于未排序的数据序列，在已排序序列中从后向前扫描，找到相应的位置并插入，类似打扑克牌时的码牌。插入排序有一种优化的算法，可以进行拆半插入。

基本思路是先将待排序序列的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；然后从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置，直到所有数据都完成排序；如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。
![[插入排序.webp]]

```
public static void InsertionSort(int[] arr)
{
    int n = arr.Length;
    for (int i = 1; i < n; i++)
    {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

<span style="color:yellow; ">4、希尔排序</span>
希尔排序也称递减增量排序，是插入排序的一种改进版本，英文称为`Shell Sort`，效率虽高，但它是一种不稳定的排序算法。

插入排序在对几乎已经排好序的数据操作时，效果是非常好的；但是插入排序每次只能移动一位数据，因此插入排序效率比较低。

希尔排序在插入排序的基础上进行了改进，它的基本思路是先将整个数据序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全部数据进行依次直接插入排序。
![[希尔排序.webp.jpg]]
```
public static void ShellSort(int[] arr)
{
    int n = arr.Length;
    int gap = n / 2;
    while (gap > 0)
    {
        for (int i = gap; i < n; i++)
        {
            int temp = arr[i];
            int j = i;
            while (j >= gap && arr[j - gap] > temp)
            {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;
        }
        gap /= 2;
    }
}
```

<span style="color:yellow; ">5、归并排序</span>
归并排序（Merge Sort）是一种分治算法，它将列表递归地拆分成较小的子列表，然后将这些子列表进行合并，直到整个列表有序。
![[归并排序.gif]]
```
public static void MergeSort(int[] arr)
{
    if (arr.Length <= 1)
        return;

    int mid = arr.Length / 2;
    int[] left = new int[mid];
    int[] right = new int[arr.Length - mid];

    Array.Copy(arr, 0, left, 0, mid);
    Array.Copy(arr, mid, right, 0, arr.Length - mid);

    MergeSort(left);
    MergeSort(right);

    Merge(arr, left, right);
}

private static void Merge(int[] arr, int[] left, int[] right)
{
    int i = 0, j = 0, k = 0;

    while (i < left.Length && j < right.Length)
    {
        if (left[i] <= right[j])
        {
            arr[k] = left[i];
            i++;
        }
        else
        {
            arr[k] = right[j];
            j++;
        }
        k++;
    }

    while (i < left.Length)
    {
        arr[k] = left[i];
        i++;
        k++;
    }

    while (j < right.Length)
    {
        arr[k] = right[j];
        j++;
        k++;
    }
}
```

<span style="color:yellow; ">6、快速排序</span>
快速排序（Quick Sort）是一种常用的排序算法，它使用分治的思想将列表划分为较小和较大的子列表，然后递归地对子列表进行排序。
![[快速排序.webp]]
```
public static void QuickSort(int[] arr, int low, int high)
{
    if (low < high)
    {
        int pivotIndex = Partition(arr, low, high);
        QuickSort(arr, low, pivotIndex - 1);
        QuickSort(arr, pivotIndex + 1, high);
    }
}

private static int Partition(int[] arr, int low, int high)
{
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++)
    {
        if (arr[j] < pivot)
        {
            i++;
            Swap(arr, i, j);
        }
    }

    Swap(arr, i + 1, high);
    return i + 1;
}

private static void Swap(int[] arr, int i, int j)
{
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

<span style="color:yellow; ">7、堆排序</span>
堆排序（Heap Sort）是一种基于二叉堆的排序算法，它通过构建最大堆或最小堆来实现排序。
![[堆排序.mp4]]

```
public static void HeapSort(int[] arr)
{
    int n = arr.Length;

    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; i--)
    {
        Heapify(arr, n, i);
    }

    // 逐步将最大值交换至堆末尾，然后重新调整堆
    for (int i = n - 1; i > 0; i--)
    {
        // 将根节点与当前末尾元素交换
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // 调整剩余的堆
        Heapify(arr, i, 0);
    }
}

private static void Heapify(int[] arr, int n, int i)
{
    int largest = i; // 最大元素的索引
    int left = 2 * i + 1; // 左子节点的索引
    int right = 2 * i + 2; // 右子节点的索引

    // 如果左子节点大于根节点，更新最大元素的索引
    if (left < n && arr[left] > arr[largest])
    {
        largest = left;
    }

    // 如果右子节点大于根节点，更新最大元素的索引
    if (right < n && arr[right] > arr[largest])
    {
        largest = right;
    }

    // 如果最大元素的索引不是根节点，交换根节点与最大元素
    if (largest != i)
    {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // 递归地对被交换的子树进行堆化
        Heapify(arr, n, largest);
    }
}
```

<span style="color:yellow; ">8、计数排序</span>
计数排序英文称Counting sort，是一种稳定的线性时间排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于 i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。基本的步骤如下：

1. 找出待排序的数组中最大和最小的元素
2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
3. 对所有的计数累加,从C中的第一个元素开始，每一项和前一项相加
4. 反向填充目标数组,将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1

![[计数排序.webp]]
```
public static void CountingSort(int[] arr)
{
    int n = arr.Length;

    // 找到数组中的最大值，确定计数数组的大小
    int max = arr[0];
    for (int i = 1; i < n; i++)
    {
        if (arr[i] > max)
        {
            max = arr[i];
        }
    }

    // 创建计数数组并进行计数
    int[] countArray = new int[max + 1];
    for (int i = 0; i < n; i++)
    {
        countArray[arr[i]]++;
    }

    // 根据计数数组重构原始数组
    int index = 0;
    for (int i = 0; i <= max; i++)
    {
        while (countArray[i] > 0)
        {
            arr[index] = i;
            index++;
            countArray[i]--;
        }
    }
}
```


<span style="color:yellow; ">9、桶排序</span>
桶排序也称为箱排序，英文称为 Bucket Sort。它是将数组划分到一定数量的有序的桶里，然后再对每个桶中的数据进行排序，最后再将各个桶里的数据有序的合并到一起。

![[桶排序.gif]]

```
public static void BucketSort(int[] arr, int bucketSize)
{
    if (arr.Length <= 1)
        return;

    int minValue = arr[0];
    int maxValue = arr[0];
    for (int i = 1; i < arr.Length; i++)
    {
        if (arr[i] < minValue)
        {
            minValue = arr[i];
        }
        else if (arr[i] > maxValue)
        {
            maxValue = arr[i];
        }
    }

    int bucketCount = (maxValue - minValue) / bucketSize + 1;
    List<List<int>> buckets = new List<List<int>>();
    for (int i = 0; i < bucketCount; i++)
    {
        buckets.Add(new List<int>());
    }

    for (int i = 0; i < arr.Length; i++)
    {
        int bucketIndex = (arr[i] - minValue) / bucketSize;
        buckets[bucketIndex].Add(arr[i]);
    }

    int index = 0;
    for (int i = 0; i < bucketCount; i++)
    {
        int[] bucketArray = buckets[i].ToArray();
        InsertionSort(bucketArray); // 使用插入排序对每个桶进行排序
        for (int j = 0; j < bucketArray.Length; j++)
        {
            arr[index] = bucketArray[j];
            index++;
        }
    }
}

private static void InsertionSort(int[] arr)
{
    for (int i = 1; i < arr.Length; i++)
    {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

<span style="color:yellow; ">10、基数排序</span>
基数排序英文称Radix sort，是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串和特定格式的浮点数，所以基数排序也仅限于整数。它首先将所有待比较数值，统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

![[基数排序.webp]]

```
public static void RadixSort(int[] arr)
{
    if (arr.Length <= 1)
        return;

    int max = GetMaxValue(arr);

    for (int exp = 1; max / exp > 0; exp *= 10)
    {
        CountingSortByDigit(arr, exp);
    }
}

private static int GetMaxValue(int[] arr)
{
    int max = arr[0];
    for (int i = 1; i < arr.Length; i++)
    {
        if (arr[i] > max)
        {
            max = arr[i];
        }
    }
    return max;
}

private static void CountingSortByDigit(int[] arr, int exp)
{
    int n = arr.Length;
    int[] output = new int[n];
    int[] count = new int[10];

    for (int i = 0; i < n; i++)
    {
        int digit = (arr[i] / exp) % 10;
        count[digit]++;
    }

    for (int i = 1; i < 10; i++)
    {
        count[i] += count[i - 1];
    }

    for (int i = n - 1; i >= 0; i--)
    {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }

    for (int i = 0; i < n; i++)
    {
        arr[i] = output[i];
    }
}
```


