---
name: agent-native-audit
description: 对代理原生架构原则进行全面审查并生成评分报告
argument-hint: "[可选：指定要审查的原则]"
---

# 代理原生架构审查

针对代理原生架构原则对代码库进行全面审查,为每个原则启动并行子代理,并生成评分报告。

## 要审查的核心原则

1. **操作对等性** - "用户能做的任何事情,代理都能做"
2. **工具即原语** - "工具提供能力,而非行为"
3. **上下文注入** - "系统提示包含关于应用状态的动态上下文"
4. **共享工作空间** - "代理和用户在同一数据空间工作"
5. **CRUD 完整性** - "每个实体都有完整的 CRUD(创建、读取、更新、删除)"
6. **UI 集成** - "代理操作立即反映在 UI 中"
7. **能力发现** - "用户可以发现代理能做什么"
8. **提示原生特性** - "功能是定义结果的提示,而非代码"

## 工作流程

### 步骤 1: 加载代理原生技能

首先,调用 agent-native-architecture 技能以了解所有原则:

```
/compound-engineering:agent-native-architecture
```

选择选项 7(操作对等性)以加载完整的参考资料。

### 步骤 2: 启动并行子代理

使用 Task 工具和 `subagent_type: Explore` 启动 8 个并行子代理,每个原则一个。每个代理应该:

1. 枚举代码库中的所有实例(用户操作、工具、上下文、数据存储等)
2. 检查是否符合原则
3. 提供具体评分,如 "X/Y(百分比%)"
4. 列出具体差距和建议

<sub-agents>

**代理 1: 操作对等性**
```
审查操作对等性 - "用户能做的任何事情,代理都能做"

任务:
1. 枚举前端的所有用户操作(API 调用、按钮点击、表单提交)
   - 搜索 API 服务文件、fetch 调用、表单处理程序
   - 检查路由和组件中的用户交互
2. 检查哪些具有相应的代理工具
   - 搜索代理工具定义
   - 将用户操作映射到代理能力
3. 评分: "代理可以执行 Y 个用户操作中的 X 个"

格式:
## 操作对等性审查
### 发现的用户操作
| 操作 | 位置 | 代理工具 | 状态 |
### 评分: X/Y (百分比%)
### 缺失的代理工具
### 建议
```

**代理 2: 工具即原语**
```
审查工具即原语 - "工具提供能力,而非行为"

任务:
1. 查找并读取所有代理工具文件
2. 将每个工具分类为:
   - 原语(良好): read、write、store、list - 在没有业务逻辑的情况下提供能力
   - 工作流(不良): 编码业务逻辑、做出决策、编排步骤
3. 评分: "Y 个工具中有 X 个是适当的原语"

格式:
## 工具即原语审查
### 工具分析
| 工具 | 文件 | 类型 | 推理 |
### 评分: X/Y (百分比%)
### 有问题的工具(应该是原语的工作流)
### 建议
```

**代理 3: 上下文注入**
```
审查上下文注入 - "系统提示包含关于应用状态的动态上下文"

任务:
1. 查找上下文注入代码(搜索"context"、"系统提示"、"inject")
2. 读取代理提示和系统消息
3. 枚举已注入的内容与应该注入的内容:
   - 可用资源(文件、草稿、文档)
   - 用户偏好/设置
   - 最近的活动
   - 列出的可用能力
   - 会话历史
   - 工作空间状态

格式:
## 上下文注入审查
### 上下文类型分析
| 上下文类型 | 是否注入? | 位置 | 备注 |
### 评分: X/Y (百分比%)
### 缺失的上下文
### 建议
```

**代理 4: 共享工作空间**
```
审查共享工作空间 - "代理和用户在同一数据空间工作"

任务:
1. 识别所有数据存储/表/模型
2. 检查代理是否读/写相同的表或单独的表
3. 寻找沙箱隔离反模式(代理有单独的数据空间)

格式:
## 共享工作空间审查
### 数据存储分析
| 数据存储 | 用户访问 | 代理访问 | 共享? |
### 评分: X/Y (百分比%)
### 隔离的数据(反模式)
### 建议
```

**代理 5: CRUD 完整性**
```
审查 CRUD 完整性 - "每个实体都有完整的 CRUD"

任务:
1. 识别代码库中的所有实体/模型
2. 对于每个实体,检查代理工具是否存在:
   - 创建
   - 读取
   - 更新
   - 删除
3. 每个实体的评分和总体评分

格式:
## CRUD 完整性审查
### 实体 CRUD 分析
| 实体 | 创建 | 读取 | 更新 | 删除 | 评分 |
### 总体评分: X/Y 个实体具有完整 CRUD (百分比%)
### 不完整的实体(列出缺失的操作)
### 建议
```

**代理 6: UI 集成**
```
审查 UI 集成 - "代理操作立即反映在 UI 中"

任务:
1. 检查代理写入/更改如何传播到前端
2. 寻找:
   - 流式更新(SSE、WebSocket)
   - 轮询机制
   - 共享状态/服务
   - 事件总线
   - 文件监视
3. 识别"静默操作"反模式(代理更改状态但 UI 不更新)

格式:
## UI 集成审查
### 代理操作 → UI 更新分析
| 代理操作 | UI 机制 | 立即? | 备注 |
### 评分: X/Y (百分比%)
### 静默操作(反模式)
### 建议
```

**代理 7: 能力发现**
```
审查能力发现 - "用户可以发现代理能做什么"

任务:
1. 检查这 7 种发现机制:
   - 显示代理能力的入门流程
   - 帮助文档
   - UI 中的能力提示
   - 代理在响应中自我描述
   - 建议的提示/操作
   - 空状态指导
   - 斜杠命令(/help、/tools)
2. 对 7 种机制进行评分

格式:
## 能力发现审查
### 发现机制分析
| 机制 | 存在? | 位置 | 质量 |
### 评分: X/7 (百分比%)
### 缺失的发现
### 建议
```

**代理 8: 提示原生特性**
```
审查提示原生特性 - "功能是定义结果的提示,而非代码"

任务:
1. 读取所有代理提示
2. 将每个功能/行为分类为定义在:
   - 提示(良好):用自然语言定义结果
   - 代码(不良):业务逻辑硬编码
3. 检查行为更改是否需要提示编辑或代码更改

格式:
## 提示原生特性审查
### 功能定义分析
| 功能 | 定义在 | 类型 | 备注 |
### 评分: X/Y (百分比%)
### 代码定义的功能(反模式)
### 建议
```

</sub-agents>

### 步骤 3: 编制摘要报告

所有代理完成后,编制包含以下内容的摘要:

```markdown
## 代理原生架构审查: [项目名称]

### 总体评分摘要

| 核心原则 | 评分 | 百分比 | 状态 |
|----------------|-------|------------|--------|
| 操作对等性 | X/Y | Z% | ✅/⚠️/❌ |
| 工具即原语 | X/Y | Z% | ✅/⚠️/❌ |
| 上下文注入 | X/Y | Z% | ✅/⚠️/❌ |
| 共享工作空间 | X/Y | Z% | ✅/⚠️/❌ |
| CRUD 完整性 | X/Y | Z% | ✅/⚠️/❌ |
| UI 集成 | X/Y | Z% | ✅/⚠️/❌ |
| 能力发现 | X/Y | Z% | ✅/⚠️/❌ |
| 提示原生特性 | X/Y | Z% | ✅/⚠️/❌ |

**总体代理原生评分: X%**

### 状态图例
- ✅ 优秀(80%+)
- ⚠️ 部分(50-79%)
- ❌ 需要改进(<50%)

### 按影响力排名的前 10 项建议

| 优先级 | 操作 | 原则 | 工作量 |
|----------|--------|-----------|--------|

### 表现出色的地方

[列出前 5 项优势]
```

## 成功标准

- [ ] 所有 8 个子代理完成其审查
- [ ] 每个原则都有具体的数字评分(X/Y 格式)
- [ ] 摘要表显示所有评分和状态指示器
- [ ] 前 10 项建议按影响力排序
- [ ] 报告识别优势和差距

## 可选: 单个原则审查

如果 $ARGUMENTS 指定单个原则(例如,"action parity"),则仅运行该子代理并提供该原则的详细发现。

有效参数:
- `action parity` 或 `1`
- `tools` 或 `primitives` 或 `2`
- `context` 或 `injection` 或 `3`
- `shared` 或 `workspace` 或 `4`
- `crud` 或 `5`
- `ui` 或 `integration` 或 `6`
- `discovery` 或 `7`
- `prompt` 或 `features` 或 `8`
