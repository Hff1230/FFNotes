<overview>
文件是以智能体为本应用程序的通用接口。智能体自然地熟悉文件操作——它们已经知道如何读取、写入和组织文件。本文档涵盖了为什么文件如此有效、如何组织它们以及用于积累知识的 context.md 模式。
</overview>

<why_files>
## 为什么使用文件

智能体天生擅长文件。Claude Code 之所以有效，是因为 bash + 文件系统是经过最充分测试的智能体界面。在构建以智能体为本的应用程序时，请利用这一点。

### 智能体已经知道如何

您不需要教智能体您的 API——它已经知道 `cat`、`grep`、`mv`、`mkdir`。文件操作是它最熟练的原语。

### 文件是可检查的

用户可以看到智能体创建的内容、编辑它、移动它、删除它。没有黑盒。对智能体行为的完全透明。

### 文件是可移植的

导出是微不足道的。备份是微不足道的。用户拥有他们的数据。没有供应商锁定，没有复杂的迁移路径。

### 应用状态保持同步

在移动设备上，如果您将文件系统与 iCloud 一起使用，所有设备共享相同的文件系统。智能体在一个设备上的工作会出现在所有设备上——无需您构建服务器。

### 目录结构是信息架构

文件系统免费为您提供层次结构。`/projects/acme/notes/` 以 `SELECT * FROM notes WHERE project_id = 123` 无法实现的方式自我记录。
</why_files>

<file_organization>
## 文件组织模式

> **需要验证：** 这些约定是一种迄今为止有效的方法，而不是处方。应该考虑更好的解决方案。

以智能体为本设计的一般原则：**为智能体可以推理的内容设计。** 最好的代理是人类可以理解的内容。如果人类可以查看您的文件结构并了解发生了什么，智能体可能也可以。

### 实体范围的目录

围绕实体而不是行动者或文件类型组织文件：

```
{entity_type}/{entity_id}/
├── 主要内容
├── 元数据
└── 相关材料
```

**示例：** `Research/books/{bookId}/` 包含关于一本书的所有内容——全文、笔记、来源、智能体日志。

### 命名约定

| 文件类型 | 命名模式 | 示例 |
|-----------|---------------|---------|
| 实体数据 | `{entity}.json` | `library.json`、`status.json` |
| 人类可读的内容 | `{content_type}.md` | `introduction.md`、`profile.md` |
| 智能体推理 | `agent_log.md` | 每个实体的智能体历史 |
| 主要内容 | `full_text.txt` | 下载/提取的文本 |
| 多卷 | `volume{N}.txt` | `volume1.txt`、`volume2.txt` |
| 外部来源 | `{source_name}.md` | `wikipedia.md`、`sparknotes.md` |
| 检查点 | `{sessionId}.checkpoint` | 基于 UUID |
| 配置 | `config.json` | 功能设置 |

### 目录命名

- **实体范围：** `{entityType}/{entityId}/`（例如 `Research/books/{bookId}/`）
- **类型范围：** `{type}/`（例如 `AgentCheckpoints/`、`AgentLogs/`）
- **约定：** 小写带下划线，而不是驼峰命名

### 临时与持久分离

将智能体工作文件与用户的永久数据分开：

```
Documents/
├── AgentCheckpoints/     # 临时（可以删除）
│   └── {sessionId}.checkpoint
├── AgentLogs/            # 临时（调试）
│   └── {type}/{sessionId}.md
└── Research/             # 持久（用户的工作）
    └── books/{bookId}/
```

### 拆分：Markdown 与 JSON

- **Markdown：** 用于用户可能阅读或编辑的内容
- **JSON：** 用于应用查询的结构化数据
</file_organization>

<context_md_pattern>
## context.md 模式

智能体在每个会话开始时读取并随着学习而更新的文件：

```markdown
# 上下文

## 我是谁
Every 应用程序的阅读助手。

## 我对此用户的了解
- 对军事历史和俄罗斯文学感兴趣
- 偏好简洁的分析
- 正在阅读《战争与和平》

## 存在什么
- /notes 中的 12 条笔记
- 3 个活跃项目
- 用户偏好位于 /preferences.md

## 最近的活动
- 用户创建了"项目启动"（2 小时前）
- 分析了关于奥斯特里茨的段落（昨天）

## 我的指导原则
- 不要剧透他们正在阅读的书籍
- 使用他们的兴趣来个性化见解

## 当前状态
- 没有待处理的任务
- 最后同步：10 分钟前
```

### 好处

- **智能体行为在不更改代码的情况下演变** - 更新上下文，行为改变
- **用户可以检查和修改** - 完全透明
- **积累上下文的自然位置** - 学习在会话之间持久存在
- **跨会话可移植** - 重启智能体，知识保留

### 它如何工作

1. 智能体在会话开始时读取 `context.md`
2. 智能体在学习重要内容时更新它
3. 系统也可以更新它（最近的活动、新资源）
4. 上下文在会话之间持久存在

### 包括什么

| 部分 | 目的 |
|---------|---------|
| 我是谁 | 智能体身份和角色 |
| 我对此用户的了解 | 学习的偏好、兴趣 |
| 存在什么 | 可用的资源、数据 |
| 最近的活动 | 连续性的上下文 |
| 我的指导原则 | 学习的规则和约束 |
| 当前状态 | 会话状态、待处理项目 |
</context_md_pattern>

<files_vs_database>
## 文件与数据库

> **需要验证：** 这种框架受移动开发启发。对于 Web 应用，权衡是不同的。

| 将文件用于... | 将数据库用于... |
|------------------|---------------------|
| 用户应该阅读/编辑的内容 | 大量结构化数据 |
| 受益于版本控制的配置 | 需要复杂查询的数据 |
| 智能体生成的内容 | 临时状态（会话、缓存）|
| 受益于透明度的任何内容 | 具有关系的数据 |
| 大型文本内容 | 需要索引的数据 |

**原则：** 文件用于可读性，数据库用于结构。如有疑问，使用文件——它们更透明，用户始终可以检查它们。

### 文件何时效果最好

- 规模很小（一个用户的图书馆，而不是数百万条记录）
- 透明度比查询速度更受重视
- 云同步（iCloud、Dropbox）与文件配合良好

### 混合方法

即使您出于性能原因需要数据库，也要考虑维护基于文件的"事实来源"，智能体与其一起工作，并同步到数据库以用于 UI：

```
文件（智能体工作区）：
  Research/book_123/introduction.md

数据库（UI 查询）：
  research_index: { bookId, path, title, createdAt }
```
</files_vs_database>

<conflict_model>
## 冲突模型

如果智能体和用户写入相同的文件，您需要冲突模型。

### 当前现实

大多数实现通过原子写入使用**最后写入获胜**：

```swift
try data.write(to: url, options: [.atomic])
```

这很简单，但可能会丢失更改。

### 选项

| 策略 | 优点 | 缺点 |
|----------|------|------|
| **最后写入获胜** | 简单 | 可能会丢失更改 |
| **智能体在写入之前检查** | 保留用户编辑 | 更多复杂性 |
| **独立空间** | 没有冲突 | 协作较少 |
| **仅追加日志** | 从不覆盖 | 文件永远增长 |
| **文件锁定** | 安全并发访问 | 复杂性，可能阻塞 |

### 推荐方法

**对于智能体频繁写入的文件（日志、状态）：** 最后写入获胜是可以的。冲突很少见。

**对于用户编辑的文件（配置文件、笔记）：** 考虑显式处理：
- 智能体在覆盖之前检查修改时间
- 或者将智能体输出与用户可编辑的内容分开
- 或者使用仅追加模式

### iCloud 考虑

iCloud 同步增加了复杂性。当同步冲突发生时，它会创建 `{filename} (conflict).md` 文件。监控这些：

```swift
NotificationCenter.default.addObserver(
    forName: .NSMetadataQueryDidUpdate,
    ...
)
```

### 系统提示指导

告诉智能体有关冲突模型：

```markdown
## 使用用户内容

当您创建内容时，用户可能随后编辑它。在修改之前始终读取
现有文件——用户可能进行了您应该保留的改进。

如果文件在您上次写入后被修改，请在覆盖之前询问。
```
</conflict_model>

<examples>
## 示例：阅读应用程序文件结构

```
Documents/
├── Library/
│   └── library.json              # 书籍元数据
├── Research/
│   └── books/
│       └── {bookId}/
│           ├── full_text.txt     # 下载的内容
│           ├── introduction.md   # 智能体生成、用户可编辑
│           ├── notes.md          # 用户笔记
│           └── sources/
│               ├── wikipedia.md  # 智能体收集的研究
│               └── reviews.md
├── Chats/
│   └── {conversationId}.json     # 聊天历史
├── Profile/
│   └── profile.md                # 用户阅读配置文件
└── context.md                    # 智能体的积累知识
```

**它如何工作：**

1. 用户添加书籍 → 在 `library.json` 中创建条目
2. 智能体下载文本 → 保存到 `Research/books/{id}/full_text.txt`
3. 智能体研究 → 保存到 `sources/`
4. 智能体生成介绍 → 保存到 `introduction.md`
5. 用户编辑介绍 → 智能体在下次读取时看到更改
6. 智能体使用学习内容更新 `context.md`
</examples>

<checklist>
## 文件作为通用接口检查清单

### 组织
- [ ] 实体范围的目录（`{type}/{id}/`）
- [ ] 一致的命名约定
- [ ] 临时与持久分离
- [ ] Markdown 用于人类内容，JSON 用于结构化数据

### context.md
- [ ] 智能体在会话开始时读取上下文
- [ ] 智能体在学习时更新上下文
- [ ] 包括：身份、用户知识、存在什么、指导原则
- [ ] 在会话之间持久存在

### 冲突处理
- [ ] 定义了冲突模型（最后写入获胜、写入前检查等）
- [ ] 系统提示中的智能体指导
- [ ] iCloud 冲突监控（如适用）

### 集成
- [ ] UI 观察文件更改（或共享服务）
- [ ] 智能体可以读取用户编辑
- [ ] 用户可以检查智能体输出
</checklist>
